>>>>>> from __future__ import annotations
>>>>>> from typing import List, Optional, Tuple
>>>>>> from .types import Player, Move, Piece
>>>>>> from .board import Board, DEN_POS
>>>>>> from .rules import is_legal_move
       
       
>>>>>> class GameState:
>>>>>>     def __init__(self) -> None:
    5:         self.board = Board()
    5:         self.current_player: Player = Player.P1
    5:         self.history: List[Move] = []
    5:         self.undo_used = {Player.P1: 0, Player.P2: 0}
    5:         self.players_name = {Player.P1: "Player1", Player.P2: "Player2"}
    5:         self._winner: Optional[Player] = None
       
>>>>>>     def set_player_names(self, p1: str, p2: str) -> None:
>>>>>>         self.players_name[Player.P1] = p1
>>>>>>         self.players_name[Player.P2] = p2
       
>>>>>>     def winner(self) -> Optional[Player]:
>>>>>>         return self._winner
       
>>>>>>     def _check_winner(self) -> Optional[Player]:
               # Enter enemy den
    9:         for owner in (Player.P1, Player.P2):
    6:             ex, ey = DEN_POS[owner]
    6:             piece = self.board.piece_at(ex, ey)
    6:             if piece and piece.owner != owner:
>>>>>>                 self._winner = piece.owner
>>>>>>                 return self._winner
               # Or capture all opponent pieces
    9:         for owner in (Player.P1, Player.P2):
    6:             if len(self.board.owner_pieces(owner)) == 0:
>>>>>>                 self._winner = owner.opponent()
>>>>>>                 return self._winner
    3:         return None
       
>>>>>>     def legal_move(self, from_xy: Tuple[int, int], to_xy: Tuple[int, int]) -> Tuple[bool, str]:
    8:         fx, fy = from_xy
    8:         tx, ty = to_xy
    8:         piece = self.board.piece_at(fx, fy)
    8:         if piece is None:
>>>>>>             return False, "起始位置没有棋子"
    8:         if piece.owner != self.current_player:
>>>>>>             return False, "不是你的回合"
    8:         ok, reason = is_legal_move(self.board, piece, tx, ty)
    8:         return ok, reason
       
>>>>>>     def move(self, from_xy: Tuple[int, int], to_xy: Tuple[int, int]) -> Tuple[bool, str]:
    3:         ok, reason = self.legal_move(from_xy, to_xy)
    3:         if not ok:
>>>>>>             return False, reason
    3:         fx, fy = from_xy
    3:         tx, ty = to_xy
    3:         piece = self.board.remove_piece(fx, fy)
    3:         assert piece is not None
    3:         captured = self.board.remove_piece(tx, ty)
    3:         self.board.place_piece(piece, tx, ty)
    3:         mv = Move(self.current_player, from_xy, to_xy, piece.animal, captured)
    3:         self.history.append(mv)
    3:         self._check_winner()
    3:         self.current_player = self.current_player.opponent()
    3:         return True, ""
       
>>>>>>     def undo(self) -> Tuple[bool, str]:
    4:         if len(self.history) == 0:
    1:             return False, "无可撤销的步数"
    3:         prev_player = self.current_player.opponent()
    3:         if self.undo_used[prev_player] >= 3:
>>>>>>             return False, "每位玩家最多悔棋3次"
    3:         mv = self.history.pop()
               # revert move
    3:         piece = self.board.remove_piece(*mv.to_pos)
    3:         assert piece is not None
    3:         self.board.place_piece(piece, *mv.from_pos)
    3:         if mv.captured is not None:
>>>>>>             self.board.place_piece(mv.captured, *mv.to_pos)
    3:         self.undo_used[prev_player] += 1
    3:         self._winner = None
    3:         self.current_player = prev_player
    3:         return True, ""
       
>>>>>>     def reset(self) -> None:
>>>>>>         self.__init__()
       
>>>>>>     def status_lines(self) -> List[str]:
               # Render simple ASCII board with pieces
>>>>>>         def piece_char(p: Piece) -> str:
>>>>>>             c = {
>>>>>>                 1: 'r', 2: 'c', 3: 'd', 4: 'w', 5: 'l', 6: 't', 7: 'L', 8: 'e'
>>>>>>             }[p.animal.value]
>>>>>>             return c.upper() if p.owner == Player.P1 else c
>>>>>>         lines: List[str] = []
>>>>>>         header = "   a b c d e f g"
>>>>>>         lines.append(header)
>>>>>>         for y in range(9):
>>>>>>             row = [str(y + 1).rjust(2)]
>>>>>>             for x in range(7):
>>>>>>                 p = self.board.piece_at(x, y)
>>>>>>                 if p:
>>>>>>                     row.append(piece_char(p))
                       else:
                           # water ~, den D/d, trap ^/v, land .
>>>>>>                     st = self.board.square_type(x, y)
>>>>>>                     ch = {
>>>>>>                         1: '~', 2: '^', 3: 'v', 4: 'D', 5: 'd'
>>>>>>                     }.get(st.value, '.')
>>>>>>                     row.append(ch)
>>>>>>             lines.append(" ".join(row))
>>>>>>         lines.append(f"回合: {self.players_name[self.current_player]} ({'P1' if self.current_player==Player.P1 else 'P2'})")
>>>>>>         if self._winner:
>>>>>>             lines.append(f"胜者: {self.players_name[self._winner]} ({'P1' if self._winner==Player.P1 else 'P2'})")
>>>>>>         return lines
